import Foundation

/// Supported in Teams, not in Bot Framework.
/// The Office 365 Connector card provides a flexible layout with multiple sections, fields, images, and actions.
/// This card encapsulates a connector card so that it can be used by bots.
/// See the notes section for differences between connector cards and the O365 card.
///
/// Compatibility:
///  - Bots in Teams: ✔
///  - Messaging Extensions: ✔
///  - Connectors: ✔
///  - Bot Framework: ✖
///  - Teams: ✔
public struct O365ConnectorCard: CardType {
    /// Required. Must be set to MessageCard.
    public let type: String
    /// Required. Must be set to https://schema.org/extensions.
    public let context: String
    /// The correlationId property simplifies the process of locating logs for troubleshooting issues.
    /// We recommend that when sending an actionable card, your service should set and log a unique UUID in this property.
    /// When the user invokes an action on the card, Office 365 sends the Card-Correlation-Id and Action-Request-Id headers in the POST request to your service.
    /// Card-Correlation-Id contains the same value as the correlationId property in the card. Action-Request-Id is a unique UUID generated by Office 365 to help locate specific action performed by a user.
    /// Your service should log both of these values when receiving action POST requests.
    public let correlationId: UUID?
    /// Optional. This contains a list of expected email addresses of the recipient for the action endpoint.
    /// A user can have multiple email addresses and the action endpoint might not be expecting the particular email address presented in the sub claim of the bearer token.
    /// For example, a user could have both the john.doe@contoso.com or john@contoso.com email address, but the action endpoint expects to receive john@contoso.com in the sub claim of the bearer token. By setting this field to ["john@contoso.com"], the sub claim will have the expected email address.
    public let expectedActors: [String]?
    /// Required when sent via email, not applicable when sent via connector.
    /// For actionable email, MUST be set to the provider ID generated by the Actionable Email Developer Dashboard.
    public let originator: String?
    /// Required if the card does not contain a text property, otherwise optional.
    /// The summary property is typically displayed in the list view in Outlook, as a way to quickly determine what the card is all about.
    public let summary: String?
    /// Specifies a custom brand color for the card.
    /// The color will be displayed in a non-obtrusive manner.
    public let themeColor: String?
    /// Only applies to cards in email messages. When set to true, causes the HTML body of the message to be hidden.
    /// This is very useful in scenarios where the card is a better or more useful representation of the content than the HTML body itself, which is especially true when the card contains actions (see below.)
    public let hideOriginalBody: Bool
    /// The title property is meant to be rendered in a prominent way, at the very top of the card.
    /// Use it to introduce the content of the card in such a way users will immediately know what to expect.
    public let title: String
    /// Required if the card does not contain a summary property, otherwise optional.
    /// The text property is meant to be displayed in a normal font below the card's title.
    /// Use it to display content, such as the description of the entity being referenced, or an abstract of a news article.
    public let text: String?
    /// A collection of sections to include in the card. See Section fields.
    public let sections: [Section]?
    /// A collection of actions that can be invoked on this card. See Actions.
    public let potentialAction: [Action]?
    
    enum CodingKeys: String, CodingKey {
        case type = "@type"
        case context = "@context"
        case correlationId
        case expectedActors
        case originator
        case summary
        case themeColor
        case hideOriginalBody
        case title
        case text
        case sections
        case potentialAction
    }
    
    public init(
        correlationId: UUID?,
        expectedActors: [String]?,
        originator: String?,
        summary: String?,
        themeColor: String?,
        hideOriginalBody: Bool,
        title: String,
        text: String?,
        sections: [Section]?,
        potentialAction: [Action]?
    ) {
        self.type = "MessageCard"
        self.context = "https://schema.org/extensions"
        self.correlationId = correlationId
        self.expectedActors = expectedActors
        self.originator = originator
        self.summary = summary
        self.themeColor = themeColor
        self.hideOriginalBody = hideOriginalBody
        self.title = title
        self.text = text
        self.sections = sections
        self.potentialAction = potentialAction
    }
}

extension O365ConnectorCard {
    public struct Section: Codable {
        /// The title property of a section is displayed in a font that stands out while not as prominent as the card's title.
        /// It is meant to introduce the section and summarize its content, similarly to how the card's title property is meant to summarize the whole card.
        public let title: String
        /// When set to true, the startGroup property marks the start of a logical group of information.
        /// Typically, sections with startGroup set to true will be visually separated from previous card elements.
        /// For example, Outlook uses a subtle horizontal separation line.
        public let startGroup: Bool
        /// Ex Use activityImage to display the picture of that person.
        public let activityImage: URL?
        /// Ex Use activityTitle to summarize what they did. Make it short and to the point.
        public let activityTitle: String?
        /// Ex Use activitySubtitle to show, for instance, the date and time the action was taken, or the person's handle.
        public let activitySubtitle: String?
        /// Ex Use activityText to provide details about the activity.
        public let activityText: String?
        /// Use heroImage to make an image the centerpiece of your card. For example, a tweet that contains an image will want to put that image front and center
        public let heroImage: Image?
        /// The section's text property is very similar to the text property of the card. It can be used for the same purpose.
        public let text: String?
        /// Array of name/value pairs    Facts are a very important component of a section. They often contain the information that really matters to the user.
        public let facts: [Fact]?
        /// The images property allows for the inclusion of a photo gallery inside a section.
        /// That photo gallery will always be displayed in a way that is easy to consume regardless of the form factor of the device it is being viewed on.
        /// For instance, in Outlook on the Web, images might be displayed as a horizontal strip of thumbnails with controls allowing to scroll through the collection if it doesn't all fit on the screen.
        /// On mobile, images might be displayed as a single thumbnail, with the user able to swipe through the collection with their finger.
        public let images: [Image]?
        /// A collection of actions that can be invoked on this section. See Actions.
        public let potentialAction: [Action]?
        
        public init(
            title: String,
            startGroup: Bool,
            activityImage: URL?,
            activityTitle: String?,
            activitySubtitle: String?,
            activityText: String?,
            heroImage: Image?,
            text: String?,
            facts: [Fact]?,
            images: [Image]?,
            potentialAction: [Action]?)
        {
            self.title = title
            self.startGroup = startGroup
            self.activityImage = activityImage
            self.activityTitle = activityTitle
            self.activitySubtitle = activitySubtitle
            self.activityText = activityText
            self.heroImage = heroImage
            self.text = text
            self.facts = facts
            self.images = images
            self.potentialAction = potentialAction
        }
    }
}

extension O365ConnectorCard {
    public enum ActionType: String, Codable {
        case openUri = "OpenUri"
        case httpPost = "HttpPOST"
        case actionCard = "ActionCard"
        case invokeAddInCommand = "InvokeAddInCommand"
    }
    
    public enum Action: Codable {
        case openUri(OpenUriAction)
        case httpPost(HTTPPostAction)
        case actionCard(ActionCardAction)
        case invokeAddInCommand(InvokeAddInCommandAction)
        
        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            let type = try container.decode(ActionType.self, forKey: .type)
            switch type {
            case .openUri: self = .openUri(try OpenUriAction(from: decoder))
            case .httpPost: self = .httpPost(try HTTPPostAction(from: decoder))
            case .actionCard: self = .actionCard(try ActionCardAction(from: decoder))
            case .invokeAddInCommand: self = .invokeAddInCommand(try InvokeAddInCommandAction(from: decoder))
            }
        }
        
        public func encode(to encoder: Encoder) throws {
            var container = encoder.unkeyedContainer()
            switch self {
            case .openUri(let action): try container.encode(action)
            case .httpPost(let action): try container.encode(action)
            case .actionCard(let action): try container.encode(action)
            case .invokeAddInCommand(let action): try container.encode(action)
            }
        }
        
        enum CodingKeys: String, CodingKey {
            case type = "@type"
        }
    }
    
    /// Opens a URI in a separate browser or app.
    ///
    /// Although links can be achieved through Markdown, an OpenUri action has the advantage of allowing you to specify different URIs for different operating systems, which makes it possible to open the link in an app on mobile devices.
    ///  - Consider using an OpenUri action rather than a link in Markdown if there is a clear advantage for your users in their ability to open the link in an app on their mobile device.
    ///  - Do include at least an OpenUri action to view the entity in the external app it comes from.
    ///  - Do make the OpenUri action the last one in the potentialAction collection.
    public struct OpenUriAction: Codable {
        public let type: ActionType
        /// The name property defines the text that will be displayed on screen for the action.
        public let name: String
        /// The targets property is a collection of name/value pairs that defines one URI per target operating system.
        public let targets: [Target]
        
        public init(name: String, targets: [Target]) {
            self.type = .openUri
            self.name = name
            self.targets = targets
        }
        
        enum CodingKeys: String, CodingKey {
            case type = "@type"
            case name
            case targets
        }
        
        public struct Target: Codable {
            public let os: OS
            public let uri: URL
            
            public init(os: OS, uri: URL) {
                self.os = os
                self.uri = uri
            }
            
            public enum OS: String, Codable {
                case `default`
                case windows
                case ios = "iOS"
                case android
            }
        }
    }
    
    /// Makes a call to an external Web service.
    ///
    /// When an HttpPOST action is executed, a POST request is made to the URL in the target field, and the target service needs to authenticate the caller.
    /// This can be done in a variety of ways, including via a Limited Purpose Token embedded in the target URL.
    /// For more information and help on choosing the security mechanism that works best for your particular scenario, please see Security requirements for actionable messages.
    ///
    /// HttpPOST actions can include the CARD-ACTION-STATUS HTTP header in their response.
    /// This header is meant to contain text that indicates the outcome of the action's execution, whether it has succeeded or failed.
    /// The value of the header will be displayed in a consistent way in a reserved area of the card.
    /// It is also saved with the card so it can be displayed later on, so users can be reminded of the actions that have already been executed on a given card.
    ///
    /// Refresh cards
    ///
    /// Refresh cards are a very powerful mechanism that allow HttpPOST actions to fully update the card on the fly as the action successfully completes. There are many scenarios that benefit from refresh cards:
    ///  - Approval scenario (e.g. expense report)
    ///    - Once the request is approved or rejected, the card is refreshed to remove the approve/decline actions and update its content so it reflects the fact that it's been approved or declined
    ///  - Task status
    ///    - When an action is taken on a task, such as setting its due date, the card refreshes to include the updated due date in its facts
    ///  - Survey
    ///    - Once the question has been answered, the card is refreshed so:
    ///       - It no longer allows the user to respond
    ///       - It shows updated status, like "Thanks for responding to this survey" alongside the user's actual response
    ///       - Potentially include a new OpenUri action that allows the user to consult the survey online
    ///
    /// To refresh a card as a result of an HttpPOST action, a service needs to do the following:
    ///  - Include the JSON payload of the new card in the body of the response to the HTTP POST request it received.
    ///  - Add the CARD-UPDATE-IN-BODY: true HTTP header to the response, in order to let the receiving client know that it should parse the response body and extract a new card (this is to avoid unnecessary processing when no refresh card is included.)
    public struct HTTPPostAction: Codable {
        public let type: ActionType
        /// The name property defines the text that will be displayed on screen for the action.
        public let name: String
        /// Defines the URL endpoint of the service that implements the action.
        /// Note: this URL must be accessible from the internet, you cannot use localhost.
        public let target: URL
        /// A collection of Header objects representing a set of HTTP headers that will be emitted when sending the POST request to the target URL.
        public let headers: [Header]?
        /// The body of the POST request.
        public let body: String
        /// The bodyContentType is optional and specifies the MIME type of the body in the POST request.
        /// Some services require that a content type be specified.
        /// Valid values are application/json and application/x-www-form-urlencoded. If not specified, application/json is assumed.
        public let bodyContentType: String?
        
        public init(name: String, target: URL, headers: [Header]?, body: String, bodyContentType: String?) {
            self.type = .httpPost
            self.name = name
            self.target = target
            self.headers = headers
            self.body = body
            self.bodyContentType = bodyContentType
        }
        
        enum CodingKeys: String, CodingKey {
            case type = "@type"
            case name
            case target
            case headers
            case body
            case bodyContentType
        }
        
        /// The Header object is a name/value pair that represents an HTTP header.
        public struct Header: Codable {
            /// The header name
            public let name: String
            /// The header value
            public let value: String
            
            public init(name: String, value: String) {
                self.name = name
                self.value = value
            }
        }
    }
    
    /// Presents additional UI that contains one or more Inputs, along with associated actions that can be either OpenUri or HttpPOST types.
    ///
    /// Do use an ActionCard action if an action requires additional input from the user. Some scenarios:
    /// - Responding to a survey
    /// - Adding a comment to a bug
    /// - Providing justification for declining an expense report
    ///
    /// By default, an ActionCard action will be represented as a button or link in the card's UI.
    /// When clicked, that button will display an additional piece of UI containing the inputs and actions defined in the action card.
    ///
    /// If there is a single ActionCard action in a potentialAction collection, then Outlook will represent that action "pre-expanded," e.g. its inputs and actions will be immediately visible.
    ///
    /// ```
    /// {
    ///   "@type": "ActionCard",
    ///   "name": "Comment",
    ///   "inputs": [
    ///     {
    ///       "@type": "TextInput",
    ///       "id": "comment",
    ///       "isMultiline": true,
    ///       "title": "Input's title property"
    ///     }
    ///   ],
    ///   "actions": [
    ///     {
    ///       "@type": "HttpPOST",
    ///       "name": "Action's name prop.",
    ///       "target": "https://yammer.com/comment?postId=123",
    ///       "body": "comment={{comment.value}}"
    ///     }
    ///   ]
    /// }
    /// ```
    public struct ActionCardAction: Codable {
        public let type: ActionType
        /// The name property defines the text that will be displayed on screen for the action.
        public let name: String
        /// The inputs property defines the various inputs that will be displayed in the action card's UI. See Inputs
        public let inputs: [Input]?
        /// The actions property is an array of Action objects, that can be either of type OpenUri or HttpPOST.
        /// The actions property of an ActionCard action cannot contain another ActionCard action.
        public let actions: [O365ConnectorCard.Action]?
        
        public init(name: String, inputs: [Input]?, actions: [O365ConnectorCard.Action]?) {
            self.type = .actionCard
            self.name = name
            self.inputs = inputs
            self.actions = actions
        }
        
        enum CodingKeys: String, CodingKey {
            case type = "@type"
            case name
            case inputs
            case actions
        }
    }
    
    /// Opens an Outlook add-in task pane. If the add-in is not installed, the user is prompted to install the add-in with a single click.
    ///
    /// When an InvokeAddInCommand action is executed, Outlook first checks if the requested add-in is installed and turned on for the user. If it is not, the user is notified that the action requires the add-in, and is able to install and enable the add-in with a single click.
    /// Outlook opens the requested , making any initialization context specified by the action available to the add-in.
    /// ```
    /// {
    ///   "@type": "InvokeAddInCommand",
    ///   "name": "Invoke My Add-in",
    ///   "addInId": "527104a1-f1a5-475a-9199-7a968161c870",
    ///   "desktopCommandId": "show ",
    ///   "initializationContext": {
    ///     "property1": "Hello world",
    ///     "property2": 5,
    ///     "property3": true
    ///   }
    /// }
    /// ```
    public struct InvokeAddInCommandAction: Codable {
//        public let type: ActionType
//        /// The name property defines the text that will be displayed on screen for the action.
//        public let name: String
//        /// Specifies the add-in ID of the required add-in. The add-in ID is found in the Id element in the add-in's manifest.
//        public let addInId: UUID
//        /// Specifies the ID of the add-in command button that opens the required task pane.
//        /// The command button ID is found in the id attribute of the Control element that defines the button in the add-in's manifest.
//        /// The specified Control element MUST be defined inside a MessageReadCommandSurface extension point, be of type Button, and the control's Action must be of type ShowTaskPane.
//        public let desktopCommandId: String
//        /// Optional. Developers may specify any valid JSON object in this field. The value is serialized into a string and made available to the add-in when the action is executed. This allows the action to pass initialization data to the add-in.
//        public let initializationContext: Object
    }
}

extension O365ConnectorCard.Section {
    /// Defines an image as used by the heroImage and images property of a section.
    public struct Image: Codable {
        /// The URL to the image.
        public let image: URL
        /// A short description of the image.
        public let title: String
        
        public init(image: URL, title: String) {
            self.image = image
            self.title = title
        }
    }
    
    /// Defines a key-value pair that contains a fact.
    public struct Fact: Codable {
        /// Name of the fact. For example, Check-in.
        public let name: String
        /// Value of the fact. For example, 10 October 2016.
        public let value: String
        
        public init(name: String, value: String) {
            self.name = name
            self.value = value
        }
    }
}

extension O365ConnectorCard.ActionCardAction {
    /// Three types of inputs are supported: TextInput, DateInput, and MultichoiceInput.
    ///
    /// Input value substitution
    /// The value of an input can be referenced in any URL of a ViewAction or HttpPOST action. It can also be referenced in an HttpPOST action's body. When an input value is referenced, it is substituted with the actual value of the input right before the action is executed.
    /// To reference an input's value, use the following format: `{{<id of input>.value}}`
    /// ```
    /// {
    ///   "@type": "ActionCard",
    ///   "name": "Comment",
    ///   "inputs": [
    ///     {
    ///       "@type": "TextInput",
    ///       "id": "comment",
    ///       "isMultiline": true,
    ///       "title": "Input's title property"
    ///     }
    ///   ],
    ///   "actions": [
    ///     {
    ///       "@type": "HttpPOST",
    ///       "name": "Action's name prop.",
    ///       "target": "https://yammer.com/comment?postId=123",
    ///       "body": "comment={{comment.value}}"
    ///     }
    ///   ]
    /// }
    /// ```
    public enum Input: Codable {
        case text(TextInput)
        case date(DateInput)
        case multichoice(MultichoiceInput)
        
        public init(from decoder: Decoder) throws {
            let container = try decoder.container(keyedBy: CodingKeys.self)
            let type = try container.decode(InputType.self, forKey: .type)
            switch type {
            case .text: self = .text(try TextInput(from: decoder))
            case .date: self = .date(try DateInput(from: decoder))
            case .multichoice: self = .multichoice(try MultichoiceInput(from: decoder))
            }
        }
        
        public func encode(to encoder: Encoder) throws {
            var container = encoder.unkeyedContainer()
            switch self {
            case .text(let input): try container.encode(input)
            case .date(let input): try container.encode(input)
            case .multichoice(let input): try container.encode(input)
            }
        }
        
        enum CodingKeys: String, CodingKey {
            case type = "@type"
        }
        
        public enum InputType: String, Codable {
            case text = "TextInput"
            case date = "DateInput"
            case multichoice = "MultichoiceInput"
        }

        /// Use this input type when you need users to provide free text, such as the response to a survey question.\
        ///
        /// ```
        /// {
        ///   "@type": "TextInput",
        ///   "id": "comment",
        ///   "isMultiline": true,
        ///   "title": "Input's title property"
        /// }
        /// ```
        public struct TextInput: Codable {
            /// must be TextInput, DateInput, or MultichoiceInput
            public let type: InputType
            /// Uniquely identifies the input so it is possible to reference it in the URL or body of an HttpPOST action. See Input value substitution.
            public let id: String
            /// Indicates whether users are required to type a value before they are able to take an action that would take the value of the input as a parameter.
            public let isRequired: Bool?
            /// Defines a title for the input.
            public let title: String
            /// Defines the initial value of the input. For multi-choice inputs, value must be equal to the value property of one of the input's choices.
            public let value: String?
            /// Indicates whether the text input should accept multiple lines of text.
            public let isMultiline: Bool
            /// Indicates the maximum number of characters that can be entered.
            public let maxLength: Int
            
            public init(id: String, isRequired: Bool?, title: String, value: String?, isMultiline: Bool, maxLength: Int) {
                self.type = .text
                self.id = id
                self.isRequired = isRequired
                self.title = title
                self.value = value
                self.isMultiline = isMultiline
                self.maxLength = maxLength
            }
            
            enum CodingKeys: String, CodingKey {
                case type = "@type"
                case id
                case isRequired
                case title
                case value
                case isMultiline
                case maxLength
            }
        }
        
        /// Use this input type when you need users to provide free text, such as the response to a survey question.
        ///
        /// ```
        /// {
        ///   "@type": "DateInput",
        ///   "id": "dueDate",
        ///   "title": "Input's title property"
        /// }
        /// ```
        public struct DateInput: Codable {
            /// must be TextInput, DateInput, or MultichoiceInput
            public let type: InputType
            /// Uniquely identifies the input so it is possible to reference it in the URL or body of an HttpPOST action. See Input value substitution.
            public let id: String
            /// Indicates whether users are required to type a value before they are able to take an action that would take the value of the input as a parameter.
            public let isRequired: Bool?
            /// Defines a title for the input.
            public let title: String
            /// Defines the initial value of the input. For multi-choice inputs, value must be equal to the value property of one of the input's choices.
            public let value: String?
            /// Indicates whether the date input should allow for the selection of a time in addition to the date.
            public let includeTime: Bool
            
            public init(id: String, isRequired: Bool?, title: String, value: String?, includeTime: Bool) {
                self.type = .date
                self.id = id
                self.isRequired = isRequired
                self.title = title
                self.value = value
                self.includeTime = includeTime
            }
            
            enum CodingKeys: String, CodingKey {
                case type = "@type"
                case id
                case isRequired
                case title
                case value
                case includeTime
            }
        }
        
        /// Use this input type when you need users to select from a list of pre-defined choices, such as a bug status, yes/no/maybe, etc.
        ///
        /// ```
        /// {
        ///   "@type": "MultichoiceInput",
        ///   "id": "list",
        ///   "title": "Pick an option",
        ///   "isMultiSelect": true, // optional
        ///   "style": "expanded", // optional
        ///   "choices": [
        ///     { "display": "Choice 1", "value": "1" },
        ///     { "display": "Choice 2", "value": "2" },
        ///     { "display": "Choice 3", "value": "3" }
        ///   ]
        /// }
        /// ```
        public struct MultichoiceInput: Codable {
            /// must be TextInput, DateInput, or MultichoiceInput
            public let type: InputType
            /// Uniquely identifies the input so it is possible to reference it in the URL or body of an HttpPOST action. See Input value substitution.
            public let id: String
            /// Indicates whether users are required to type a value before they are able to take an action that would take the value of the input as a parameter.
            public let isRequired: Bool?
            /// Defines a title for the input.
            public let title: String
            /// Defines the initial value of the input. For multi-choice inputs, value must be equal to the value property of one of the input's choices.
            public let value: String?
            /// Defines the values that can be selected for the multichoice input.
            public let choices: [Choice]
            /// If set to true, indicates that the user can select more than one choice.
            /// The specified choices will be displayed as a list of checkboxes. Default value is false.
            public let isMultiSelect: Bool?
            /// When isMultiSelect is false, setting the style property to expanded will instruct the host application to try and display all choices on the screen, typically using a set of radio buttons.
            public let style: Style?
            
            public init(id: String, isRequired: Bool?, title: String, value: String?, choices: [Choice], isMultiSelect: Bool?, style: Style?) {
                self.type = .multichoice
                self.id = id
                self.isRequired = isRequired
                self.title = title
                self.value = value
                self.choices = choices
                self.isMultiSelect = isMultiSelect
                self.style = style
            }
            
            enum CodingKeys: String, CodingKey {
                case type = "@type"
                case id
                case isRequired
                case title
                case value
                case choices
                case isMultiSelect
                case style
            }
            
            public enum Style: String, Codable {
                case normal
                case expanded
            }
            
            public struct Choice: Codable {
                public let display: String
                public let value: String
                
                public init(display: String, value: String) {
                    self.display = display
                    self.value = value
                }
            }
        }
    }
}
